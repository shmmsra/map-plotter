<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel File Processor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
        }

        .container {
            width: 80%;
            max-width: 900px;
            background-color: white;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        h1,
        h3 {
            text-align: center;
        }

        .header,
        .footer {
            text-align: center;
            margin-bottom: 20px;
        }

        .tools-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .tool-item {
            display: flex;
            flex-direction: column;
            background-color: #fafafa;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .tool-header {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .tool-inputs {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tool-actions {
            display: flex;
            flex-direction: row;
            gap: 10px;
            justify-content: flex-end;
            align-items: center;
        }

        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .footer button {
            margin-top: 20px;
        }

        input[type="file"] {
            margin: 10px 0;
        }

        input[type="text"] {
            padding: 8px;
            font-size: 14px;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        .checkbox-group {
            display: flex;
            gap: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #007bff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 2s linear infinite;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Excel File Processor</h1>

        <div class="header">
            <h3>Upload Excel File</h3>
            <input type="file" id="fileInput" accept=".xlsx">
            <p id="fileName"></p>
        </div>

        <div class="tools-list" id="toolsList">
            <!-- Tool items will be inserted here -->
        </div>

        <div class="footer">
            <button id="exportJSON" disabled>Export All JSON</button>
            <button id="exportExcel" disabled>Export All Excel</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Global Store
        const LocalStorage = (function () {
            class LocalStorage {
                storage = {};

                constructor() {
                    const globalStr = localStorage.getItem("global");
                    if (globalStr) {
                        this.storage['global'] = JSON.parse(globalStr);
                    } else {
                        this.storage['global'] = {};
                    }

                    const zipCodeLocationMapStr = localStorage.getItem("zipCodeLocationMap");
                    if (zipCodeLocationMapStr) {
                        this.storage['zipCodeLocationMap'] = JSON.parse(zipCodeLocationMapStr);
                    } else {
                        this.storage['zipCodeLocationMap'] = {};
                    }

                    const zipCodeDistanceMatrixStr = localStorage.getItem("zipCodeDistanceMatrix");
                    if (zipCodeDistanceMatrixStr) {
                        this.storage['zipCodeDistanceMatrix'] = JSON.parse(zipCodeDistanceMatrixStr);
                    } else {
                        this.storage['zipCodeDistanceMatrix'] = {};
                    }

                    const zipCodeTimeMatrixStr = localStorage.getItem("zipCodeTimeMatrix");
                    if (zipCodeTimeMatrixStr) {
                        this.storage['zipCodeTimeMatrix'] = JSON.parse(zipCodeTimeMatrixStr);
                    } else {
                        this.storage['zipCodeTimeMatrix'] = {};
                    }
                }

                getItems(category, key) {
                    return this.storage[category][key];
                }

                setItems(category, key, value) {
                    this.storage[category][key] = value;
                }

                save() {
                    localStorage.setItem("global", JSON.stringify(this.storage['global']));
                    localStorage.setItem("zipCodeLocationMap", JSON.stringify(this.storage['zipCodeLocationMap']));
                    localStorage.setItem("zipCodeDistanceMatrix", JSON.stringify(this.storage['zipCodeDistanceMatrix']));
                    localStorage.setItem("zipCodeTimeMatrix", JSON.stringify(this.storage['zipCodeTimeMatrix']));
                }

                clear() {
                    this.storage = {};
                    localStorage.removeItem("global");
                    localStorage.removeItem("zipCodeLocationMap");
                    localStorage.removeItem("zipCodeDistanceMatrix");
                    localStorage.removeItem("zipCodeTimeMatrix");
                }
            };
            return new LocalStorage();
        })();

        let excelData = null;
        const outputData = {};
        const networkTracker = {
            'geocode': 0,
            'distanceMatrix': 0,
        };

        async function throttleExecution(asyncFunc, argsList, params, batchSize) {
            const results = [];
            let index = 0;

            // A helper function to execute the batch
            async function executeBatch() {
                const currentBatch = [];

                // Run up to `batchSize` functions in parallel
                for (let i = 0; i < batchSize && index < argsList.length; i++, index++) {
                    currentBatch.push(asyncFunc(argsList[index], params));
                }

                // Wait for all functions in the current batch to complete
                const batchResults = await Promise.all(currentBatch);
                results.push(...batchResults);
            }

            // Keep running batches until all arguments are processed
            while (index < argsList.length) {
                await executeBatch();
            }

            return results;
        }

        function GetGeocodes(zipCode) {
            return new Promise((resolve, reject) => {
                if (!zipCode) {
                    resolve(null);
                    return;
                }

                fetch(`https://geocode.maps.co/search?q=${zipCode}&api_key=66e6c223a4210765093320zbyc476a2`)
                    .then(response => response.json())
                    .then(data => {
                        const latlanJSON = {
                            zipCode: zipCode,
                            longitude: data[0].lon,
                            latitude: data[0].lat,
                            address: data[0].display_name,
                        };
                        setTimeout(() => {
                            resolve(latlanJSON);
                        }, 10);
                    })
                    .catch(error => {
                        console.warn("GetGeocodes: Failed to get location from zip code:", error);
                        resolve(null);
                    });
                return;

                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: zipCode }, (results, status) => {
                    try {
                        if (status === "OK" && results[0]) {
                            const location = results[0].geometry.location;
                            const latlanJSON = {
                                zipCode: zipCode,
                                longitude: location.lng(),
                                latitude: location.lat(),
                                address: results[0].formatted_address,
                            };
                            resolve(latlanJSON);
                        } else {
                            console.warn(`GetGeocodes: Geocode failed for zip code ${zipCode}: ${status}`);
                            resolve(null);
                        }
                    } catch (error) {
                        console.warn("GetGeocodes: Failed to get location from zip code:", error);
                        resolve(null);
                    }
                });
            });
        }

        function GetShortestDistance(data) {
            function helperFunction(sourceDestinationPair) {
                return new Promise((resolve, reject) => {
                    const { source, destination } = sourceDestinationPair;
                    try {
                        const start = new google.maps.LatLng(source.latitude, source.longitude);
                        const end = new google.maps.LatLng(destination.latitude, destination.longitude);
                        const distance = google.maps.geometry.spherical.computeDistanceBetween(start, end);
                        resolve([{
                            source,
                            destination,
                            distance,
                        }, {
                            source: destination,
                            destination: source,
                            distance,
                        }]);
                    } catch (error) {
                        console.error("GetShortestDistance: Failed to get shortest distance:", error);
                        resolve(null);
                    }
                });
            }

            return new Promise((resolve, reject) => {
                const { sources, destinations } = data;
                const promises = [];
                sources.forEach(source => {
                    destinations.forEach(destination => {
                        promises.push(helperFunction({ source, destination }));
                    });
                });
                Promise.all(promises).then((results) => {
                    resolve(results
                        .flat()
                        .filter(r => !!r)
                        .map(r => ({ source: r.source.zipCode, destination: r.destination.zipCode, distance: r.distance }))
                    );
                });
            });
        }

        function GetTravelDistanceAndTime(data, mode = 'DRIVING') {
            return new Promise((resolve, reject) => {
                const starts = data.sources.map((loc) => new google.maps.LatLng(loc.latitude, loc.longitude));
                const ends = data.destinations.map((loc) => new google.maps.LatLng(loc.latitude, loc.longitude));
                const service = new google.maps.DistanceMatrixService();
                const promises = [];
                promises.push(new Promise(async (resolve, reject) => {
                    try {
                        const response = await service.getDistanceMatrix({
                            origins: starts,
                            destinations: ends,
                            travelMode: mode,
                            unitSystem: google.maps.UnitSystem.METRIC,
                        });
                        resolve(response);
                    } catch (error) {
                        resolve(null);
                    }
                }));
                Promise.all(promises).then((responses) => {
                    try {
                        const results = [];
                        responses.forEach((response) => {
                            if (!response) {
                                console.error("GetTravelDistanceAndTime: Failed to get travel details.");
                                return;
                            }
                            response.rows.forEach((row, i) => {
                                if (!row || !row.elements || !row.elements.length) {
                                    console.error("GetTravelDistanceAndTime: Failed to get travel details for the source.");
                                    return;
                                }
                                row.elements.forEach((element, j) => {
                                    if (element.status === 'OK') {
                                        const distance = element.distance.value;
                                        const duration = element.duration.value;
                                        results.push({
                                            source: data.sources[i].zipCode,
                                            destination: data.destinations[j].zipCode,
                                            distance,
                                            duration,
                                        });
                                    } else {
                                        console.error(
                                            "GetTravelDistanceAndTime: Failed to get travel details for the destination: source:",
                                            data.sources[i].zipCode, ", destination:", data.destinations[j].zipCode
                                        );
                                    }
                                });
                            });
                        });
                        resolve(results);
                    } catch (error) {
                        console.error("GetTravelDistanceAndTime: Failed to get travel details:", error);
                        resolve(null);
                    }
                })
            });
        }

        function GetDistanceAndTimeMatrix(sourceDestinationMatrix, params) {
            return new Promise(async (resolve, reject) => {
                const { sources, destinations } = sourceDestinationMatrix;
                const response = {};
                for (const key of Object.keys(params)) {
                    if (key === 'aerialDistance' && params[key]) {
                        try {
                            const results = await GetShortestDistance(sourceDestinationMatrix);
                            if (!results) {
                                resolve(null);
                                return;
                            }
                            results.forEach(r => {
                                const t = response[`${r.source}:${r.destination}`] || {
                                    source: r.source,
                                    destination: r.destination,
                                };
                                t.aerialDistance = r.distance;
                                response[`${r.source}:${r.destination}`] = t;
                            });
                        } catch (error) {
                            console.error("GetDistanceAndTimeMatrix: Failed to get aerial distance:", error);
                        }
                    } else if ((key === 'drivingDistanceAndTime' || key === 'bicycleDistanceAndTime') && params[key]) {
                        try {
                            let mode = '';
                            if (key === 'drivingDistanceAndTime') {
                                mode = 'DRIVING';
                            } else if (key === 'bicycleDistanceAndTime') {
                                mode = 'BICYCLING';
                            }
                            const results = await GetTravelDistanceAndTime(sourceDestinationMatrix, mode);
                            if (!results) {
                                resolve(null);
                                return;
                            }
                            results.forEach(r => {
                                const t = response[`${r.source}:${r.destination}`] || {
                                    source: r.source,
                                    destination: r.destination,
                                };
                                if (key === 'drivingDistanceAndTime') {
                                    t.drivingDistance = r.distance;
                                    t.drivingTime = r.duration;
                                } else if (key === 'bicycleDistanceAndTime') {
                                    t.bicycleDistance = r.distance;
                                    t.bicycleTime = r.duration;
                                }
                                response[`${r.source}:${r.destination}`] = t;
                            });
                        } catch (error) {
                            console.error("GetDistanceAndTimeMatrix: Failed to get driving distance and time:", error);
                        }
                    }
                }
                const results = [];
                Object.keys(response).forEach(key => {
                    results.push({ key, ...response[key] });
                });
                resolve(results);
            });
        }

        // Tools/Functions
        const tools = [
            {
                title: "Get Geocodes",
                id: "getGeocodes",
                name: "Geocodes",
                parameters: [
                    // { type: "text", label: "Column Name" }
                ],
                execute: async (data, params) => {
                    let zipCodes = [];
                    data.forEach(row => {
                        zipCodes.push(String(row['Home Postcode']).split(' ').join('').toUpperCase());
                        Object.keys(row).forEach(key => {
                            if (key.endsWith(' Office Postcode')) {
                                zipCodes.push(String(row[key]).split(' ').join('').toUpperCase());
                            }
                        });
                    });
                    zipCodes = [...new Set(zipCodes)];

                    const results = (await throttleExecution(GetGeocodes, zipCodes, null, 2)).filter(res => !!res);
                    return results;
                }
            },
            {
                title: "Get Distance and Time Matrix",
                id: "getDistanceMatrix",
                name: "DistanceTimeMatrix",
                parameters: [
                    { type: "file", label: "Geocodes map", accept: '.xlsx,.json' },
                    { type: "checkbox", label: "Aerial distance", checked: true },
                    { type: "checkbox", label: "Driving distance and time", checked: false },
                    { type: "checkbox", label: "Bicycle distance and time", checked: false },
                ],
                execute: (excelData, params) => {
                    return new Promise((resolve, reject) => {
                        if (!params[0].value) {
                            alert('Please upload Geocodes map file');
                            return;
                        }

                        let geocodeFile = null;
                        let geocodeFileType = null;
                        if (params[0].value.type.includes('officedocument')) {
                            geocodeFileType = 'xlsx';
                            geocodeFile = params[0].value;
                        } else if (params[0].value.type.includes('json')) {
                            geocodeFileType = 'json';
                            geocodeFile = params[0].value;
                        } else {
                            alert('Invalid file format. Please upload a valid file');
                            return;
                        }

                        const paramArgs = {
                            'aerialDistance': params[1].value,
                            'drivingDistanceAndTime': params[2].value,
                            'bicycleDistanceAndTime': params[3].value,
                        };

                        const reader = new FileReader();
                        reader.onload = (e) => {
                            let geocodeData = null;
                            if (geocodeFileType === 'json') {
                                const data = JSON.parse(e.target.result);
                                geocodeData = data;
                            } else {
                                const data = new Uint8Array(e.target.result);
                                const workbook = XLSX.read(data, { type: 'array' });
                                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                                geocodeData = XLSX.utils.sheet_to_json(firstSheet);
                            }

                            const sources = excelData.map(row => (String(row['Home Postcode']).split(' ').join('').toUpperCase()));
                            const destinations = [...(new Set(excelData.map(row => {
                                const officeZipCodes = [];
                                Object.keys(row).forEach(key => {
                                    if (key.endsWith(' Office Postcode')) {
                                        officeZipCodes.push(String(row[key]).split(' ').join('').toUpperCase());
                                    }
                                });
                                return officeZipCodes;
                            }).flat()))];

                            const sourceLocations = sources.map(
                                source => geocodeData.find(geo => geo.zipCode === source)
                            ).filter(geo => !!geo);
                            const destinationLocations = destinations.map(
                                destination => geocodeData.find(geo => geo.zipCode === destination)
                            ).filter(geo => !!geo);

                            const inputList = [];
                            while (destinationLocations.length) {
                                const destinations = destinationLocations.splice(0, 5);
                                inputList.push({ sources: sourceLocations, destinations: destinations });
                            }

                            throttleExecution(GetDistanceAndTimeMatrix, inputList, paramArgs, 2).then((results) => {
                                results = results.filter(r => !!r).flat(2).filter(r => !!r);
                                resolve(results);
                            });
                        };

                        if (geocodeFileType === 'json') {
                            reader.readAsText(geocodeFile);
                        } else {
                            reader.readAsArrayBuffer(geocodeFile);
                        }
                    });
                }
            }
        ];

        // Event handler for file upload
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fileName').textContent = `File: ${file.name}`;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    excelData = XLSX.utils.sheet_to_json(firstSheet);
                    alert('File loaded successfully');

                    // TODO
                    excelData = excelData.slice(0, 50);
                };
                reader.readAsArrayBuffer(file);
            }
        });

        // Load tool items
        const toolsList = document.getElementById('toolsList');
        tools.forEach((tool, index) => {
            const toolDiv = document.createElement('div');
            toolDiv.className = 'tool-item';

            // Tool title
            const toolHeader = document.createElement('div');
            toolHeader.className = 'tool-header';
            toolHeader.textContent = tool.title;
            toolDiv.appendChild(toolHeader);

            // Tool inputs
            const toolInputs = document.createElement('div');
            toolInputs.className = 'tool-inputs';
            tool.parameters.forEach(param => {
                const label = document.createElement('label');
                const input = document.createElement('input');
                input.type = param.type;
                input.placeholder = param.label;

                if (param.type === 'checkbox') {
                    const checkboxWrapper = document.createElement('div');
                    checkboxWrapper.className = 'checkbox-group';
                    input.checked = param.checked;
                    label.textContent = param.label;
                    checkboxWrapper.appendChild(input);
                    checkboxWrapper.appendChild(label);
                    toolInputs.appendChild(checkboxWrapper);
                } else if (param.type === 'file') {
                    input.placeholder = param.label;
                    input.type = 'file';
                    input.accept = param.accept;
                    toolInputs.appendChild(input);
                } else {
                    toolInputs.appendChild(input);
                }
            });

            const toolActions = document.createElement('div');
            toolActions.className = 'tool-actions';
            const executeBtn = document.createElement('button');
            executeBtn.textContent = 'Execute';
            const exportJSONBtn = document.createElement('button');
            exportJSONBtn.textContent = 'Export JSON';
            exportJSONBtn.disabled = true;
            const exportExcelBtn = document.createElement('button');
            exportExcelBtn.textContent = 'Export Excel';
            exportExcelBtn.disabled = true;

            const spinner = document.createElement('div');
            spinner.className = 'spinner';

            // Event handler for async execute function
            executeBtn.addEventListener('click', async () => {
                const inputs = Array.from(toolInputs.querySelectorAll('input')).map(input => {
                    switch (input.type) {
                        case 'checkbox':
                            return { name: input.placeholder, value: input.checked };
                        case 'file':
                            return { name: input.placeholder, value: input.files[0] };
                        default:
                            return { name: input.placeholder, value: input.value };
                    }
                });

                // Disable execute button and show spinner
                executeBtn.disabled = true;
                spinner.style.display = 'inline-block';

                try {
                    const result = await tool.execute(excelData, inputs);
                    outputData[tool.id] = result;
                } catch (error) {
                    console.error("An error occurred during execution:", error);
                    alert('An error occurred during execution');
                } finally {
                    // Hide spinner and enable execute button
                    spinner.style.display = 'none';
                    executeBtn.disabled = false;
                    exportJSONBtn.disabled = false;
                    exportExcelBtn.disabled = false;
                    document.getElementById('exportJSON').disabled = false;
                    document.getElementById('exportExcel').disabled = false;
                }
            });

            toolActions.appendChild(spinner);
            toolActions.appendChild(executeBtn);
            toolActions.appendChild(exportJSONBtn);
            toolActions.appendChild(exportExcelBtn);

            toolDiv.appendChild(toolInputs);
            toolDiv.appendChild(toolActions);
            toolsList.appendChild(toolDiv);

            exportJSONBtn.addEventListener('click', () => {
                const json = JSON.stringify(outputData[tool.id], null, 2);
                downloadFile(json, `function_${tool.id}_output.json`, 'application/json');
            });

            exportExcelBtn.addEventListener('click', () => {
                const ws = XLSX.utils.json_to_sheet(outputData[tool.id]);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, tool.id);
                XLSX.writeFile(wb, `function_${tool.id}_output.xlsx`);
            });
        });

        // Export all JSON
        document.getElementById('exportJSON').addEventListener('click', () => {
            const json = JSON.stringify(outputData, null, 2);
            downloadFile(json, 'all_functions_output.json', 'application/json');
        });

        // Export all Excel
        document.getElementById('exportExcel').addEventListener('click', () => {
            const wb = XLSX.utils.book_new();
            Object.keys(outputData).forEach(key => {
                const ws = XLSX.utils.json_to_sheet(outputData[key]);
                XLSX.utils.book_append_sheet(wb, ws, key);
            });
            XLSX.writeFile(wb, 'all_functions_output.xlsx');
        });

        // Helper function to download file
        function downloadFile(data, filename, type) {
            const file = new Blob([data], { type });
            const a = document.createElement('a');
            const url = URL.createObjectURL(file);
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            }, 0);
        }

        /**
         * Retrieves the Google Maps API Key from LocalStorage or prompts the user.
         * @returns {Promise<string>} The API Key.
         */
        async function getApiKey() {
            let apiKey = LocalStorage.getItems('global', 'GoogleMapsAPIKey');
            if (!apiKey) {
                apiKey = prompt("Please enter your Google Maps API Key:");
                if (!apiKey) {
                    alert("API Key is required. Please try again.");
                    throw new Error("INVALID_API_KEY");
                }
                LocalStorage.setItems('global', 'GoogleMapsAPIKey', apiKey);
            }
            return apiKey;
        }

        /**
         * Dynamically loads the Google Maps script.
         * @param {string} apiKey - The Google Maps API Key.
         * @returns {Promise<void>}
         */
        function loadGoogleMapsScript(apiKey) {
            return new Promise((resolve, reject) => {
                if (window.google && window.google.maps) {
                    resolve();
                    return;
                }
                const script = document.createElement("script");
                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap&libraries=geometry`;
                script.async = true;
                script.defer = true;
                script.onerror = () => reject(new Error("Failed to load Google Maps script."));
                window.initMap = () => {
                    resolve();
                };
                document.head.appendChild(script);
            });
        }

        async function initialize() {
            try {
                const apiKey = await getApiKey();
                LocalStorage.save();
                await loadGoogleMapsScript(apiKey);
            } catch (error) {
                console.error("Failed to initialize:", error);
            }
        }

        initialize();
    </script>
</body>

</html>