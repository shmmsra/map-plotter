<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Employee Office Map</title>
    <style>
        body,
        html {
            height: 100%;
            margin: 0;
            display: flex;
            flex-direction: column;
            font-family: Arial, sans-serif;
        }

        #map-container {
            display: flex;
            flex-direction: column;
            height: 100%;
            flex: 1;
        }

        #controls {
            padding: 10px;
            background-color: #f0f0f0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-btn {
            padding: 10px;
            background-color: lightcoral;
            border: none;
            cursor: pointer;
        }

        .export-btn {
            background-color: lightgreen;
        }


        #officeButtons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        #travel-info {
            padding: 10px;
            font-size: 14px;
            background-color: #f9f9f9;
            border-top: 1px solid #ddd;
        }

        #map {
            flex-grow: 1;
            width: 100%;
        }

        .office-btn {
            padding: 10px 15px;
            background-color: #4a90e2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .office-btn:hover {
            background-color: #357ab8;
        }
    </style>

    <!-- XLSX Library -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.17.5/dist/xlsx.full.min.js"></script>
</head>

<body>
    <header style="padding: 4px 16px 4px 16px; background-color: #4a90e2; color: white;">
        <h2>Upload Excel File to Plot Employee and Office Locations</h2>
    </header>
    <div id="map-container" style="display: none;">
        <div id="controls">
            <button id="resetApiKey" class="control-btn">Reset API Key</button>
            <button id="exportData" class="control-btn export-btn">Export Data</button>
            <input type="file" id="fileInput" accept=".xlsx" />
            <div id="officeButtons"></div>
        </div>
        <div id="map"></div>
        <div id="travel-info">Select an employee marker to view travel time and distance.</div>
    </div>

    <script>
        // Global Store
        const LocalStorage = (function () {
            class LocalStorage {
                storage = {};

                constructor() {
                    const zipCodeLocationMapStr = localStorage.getItem("zipCodeLocationMap");
                    if (zipCodeLocationMapStr) {
                        this.storage['zipCodeLocationMap'] = JSON.parse(zipCodeLocationMapStr);
                    } else {
                        this.storage['zipCodeLocationMap'] = {};
                    }

                    const zipCodeDistanceMatrixStr = localStorage.getItem("zipCodeDistanceMatrix");
                    if (zipCodeDistanceMatrixStr) {
                        this.storage['zipCodeDistanceMatrix'] = JSON.parse(zipCodeDistanceMatrixStr);
                    } else {
                        this.storage['zipCodeDistanceMatrix'] = {};
                    }

                    const zipCodeTimeMatrixStr = localStorage.getItem("zipCodeTimeMatrix");
                    if (zipCodeTimeMatrixStr) {
                        this.storage['zipCodeTimeMatrix'] = JSON.parse(zipCodeTimeMatrixStr);
                    } else {
                        this.storage['zipCodeTimeMatrix'] = {};
                    }
                }

                getItems(category, key) {
                    return this.storage[category][key];
                }

                setItems(category, key, value) {
                    this.storage[category][key] = value;
                }

                flush() {
                    localStorage.setItem("zipCodeLocationMap", JSON.stringify(this.storage['zipCodeLocationMap']));
                    localStorage.setItem("zipCodeDistanceMatrix", JSON.stringify(this.storage['zipCodeDistanceMatrix']));
                    localStorage.setItem("zipCodeTimeMatrix", JSON.stringify(this.storage['zipCodeTimeMatrix']));
                }
            };
            return new LocalStorage();
        })();

        // Global Variables
        let googleMap;
        let directionsService;
        let directionsRenderer;
        let trafficLayer;
        let processedData;
        let zipCodeDistanceMatrix;
        let radiusMilesThreshold = 40 * 1609.34; // Default radius in meters
        let travelTimeThreshold = 60 * 60; // Default travel time in seconds

        // Cache DOM Elements
        const mapContainer = document.getElementById('map-container');
        const fileInput = document.getElementById('fileInput');
        const officeButtonsContainer = document.getElementById('officeButtons');
        const travelInfo = document.getElementById('travel-info');

        // Event listener for reset button
        document.getElementById('resetApiKey').addEventListener('click', () => {
            localStorage.removeItem("GoogleMapsAPIKey");
            window.location.reload();
        });

        // Function to export JSON data to Excel
        function exportJsonToExcel(jsonData, fileName = "data.xlsx") {
            // 1. Create a new workbook
            const wb = XLSX.utils.book_new();

            // 2. Convert JSON data to a worksheet
            const ws = XLSX.utils.json_to_sheet(jsonData);

            // 3. Append the worksheet to the workbook
            XLSX.utils.book_append_sheet(wb, ws, "Sheet1");

            // 4. Write the workbook to a file
            XLSX.writeFile(wb, fileName);
        }

        // Event listener for export button
        document.getElementById('exportData').addEventListener('click', () => {
            if (!processedData || !processedData.employeeList.length) {
                alert("No data to export. Please upload a file first.");
                return;
            }
            function cloneEmployeesData(employeesData) {
                return employeesData.map(employee => {
                    return {
                        "Employee ID": employee.id,
                        "Job Level": employee.job_level,
                        "Line Manager": employee.line_manager,
                        "Home Postcode": employee.zip_code,
                        "Home Latitude": employee.latitude,
                        "Home Longitude": employee.longitude,
                        ...employee.offices.reduce((acc, office) => {
                            acc[office.id] = office.zip_code;
                            return acc;
                        }, {}),
                    };
                });
            }
            const employeesData = cloneEmployeesData(processedData.employeeList);
            exportJsonToExcel(employeesData, "EmployeeData.xlsx");
        });

        /**
         * Retrieves the Google Maps API Key from localStorage or prompts the user.
         * @returns {Promise<string>} The API Key.
         */
        async function getApiKey() {
            let apiKey = localStorage.getItem("GoogleMapsAPIKey");
            if (!apiKey) {
                apiKey = prompt("Please enter your Google Maps API Key:");
                if (!apiKey) {
                    alert("API Key is required. Please try again.");
                    throw new Error("INVALID_API_KEY");
                }
                localStorage.setItem("GoogleMapsAPIKey", apiKey);
            }
            return apiKey;
        }

        /**
         * Initializes the UI by fetching the API Key and loading the map.
         */
        async function showUI() {
            try {
                const apiKey = await getApiKey();
                mapContainer.style.display = "flex";
                await loadGoogleMapsScript(apiKey);
            } catch (error) {
                console.error("Failed to load the UI:", error);
            }
        }

        /**
         * Dynamically loads the Google Maps script.
         * @param {string} apiKey - The Google Maps API Key.
         * @returns {Promise<void>}
         */
        function loadGoogleMapsScript(apiKey) {
            return new Promise((resolve, reject) => {
                if (window.google && window.google.maps) {
                    resolve();
                    return;
                }
                const script = document.createElement("script");
                script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&callback=initMap&libraries=geometry`;
                script.async = true;
                script.defer = true;
                script.onerror = () => reject(new Error("Failed to load Google Maps script."));
                window.initMap = () => {
                    initializeMap();
                    resolve();
                };
                document.head.appendChild(script);
            });
        }

        /**
         * Initializes the Google Map and related services.
         */
        function initializeMap() {
            googleMap = new google.maps.Map(document.getElementById("map"), {
                center: { lat: 20.5937, lng: 78.9629 }, // Default center (India)
                zoom: 5,
                mapTypeId: "terrain",
            });

            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer();
            directionsRenderer.setMap(googleMap);

            trafficLayer = new google.maps.TrafficLayer();
            trafficLayer.setMap(googleMap);
        }

        /**
         * Handles the file upload event.
         * @param {Event} event - The file input change event.
         */
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const data = await readExcelFile(file);
                radiusMilesThreshold = prompt("Please enter the office radius threshold in miles:") * 1609.34;
                travelTimeThreshold = prompt("Please enter the travel time threshold in minutes:") * 60;

                processedData = await processWorkbook(data);
                console.info("Processed data:", processedData);

                await plotOfficeLocations(processedData.officeList);
                await plotEmployeeLocations(processedData.employeeList);
            } catch (error) {
                console.error("Error processing file:", error);
                alert("Failed to process the uploaded file. Please check the console for details.");
            }

            LocalStorage.flush();
        }

        /**
         * Reads the Excel file and returns the workbook data.
         * @param {File} file - The uploaded Excel file.
         * @returns {Promise<Array<Object>>} The merged data from all sheets.
         */
        function readExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: "array" });
                        const mergedData = [];
                        workbook.SheetNames.forEach((sheetName) => {
                            const sheet = workbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(sheet);
                            mergedData.push(...jsonData);
                        });
                        resolve(mergedData);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error("Failed to read the file."));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * Processes the workbook data to extract employee and office information.
         * @param {Array<Object>} data - The merged data from all sheets.
         * @returns {Promise<{ employeeList: Array<Object>, officeList: Array<Object> }>} The processed data.
         */
        async function processWorkbook(data) {
            const employeeList = [];
            const officeList = [];

            const officeIds = [
                'Birmingham Office Postcode',
                'Caithness Office Postcode',
                'Cardiff Office Postcode',
                'Cheadle Office Postcode',
                'Crawley Office Postcode',
                'Exeter Office Postcode',
                'Lancing Office Postcode',
                'Leeds Office Postcode',
                'Liverpool Office Postcode',
                'London Office Postcode',
                'Reading Office Postcode',
                'Worthing Office Postcode',
                'Milwaukee Office Postcode',
                'Minnesota Office Postcode',
                'New York Office Postcode',
                'RPK Office Postcode',
                'Conshohocken Office Postcode',
            ];

            for (const row of data) {
                try {
                    const homeLocation = await getLocationFromZipCode(row['Home Postcode']);
                    if (!homeLocation) {
                        console.warn(`Invalid Home Postcode for Employee ID: ${row['Employee ID']}`);
                        continue;
                    }

                    const employee = {
                        id: row['Employee ID'],
                        job_level: row['Job Level'],
                        line_manager: row['Line Manager'],
                        zip_code: row['Home Postcode'],
                        latitude: homeLocation.latitude,
                        longitude: homeLocation.longitude,
                        offices: [],
                    };
                    employeeList.push(employee);

                    // Process each office postcode for the current employee
                    for (const officeId of officeIds) {
                        const officeZip = row[officeId];
                        if (officeZip) {
                            let office = officeList.find((o) => o.id === officeId);
                            if (!office) {
                                const officeLocation = await getLocationFromZipCode(officeZip);
                                if (!officeLocation) {
                                    console.warn(`Invalid Zip Code for ${officeId}: ${officeZip}`);
                                }

                                office = {
                                    id: officeId,
                                    zip_code: officeZip,
                                    latitude: officeLocation && officeLocation.latitude,
                                    longitude: officeLocation && officeLocation.longitude,
                                    employees: [],
                                };
                                officeList.push(office);
                            }
                            office.employees.push(employee);
                            employee.offices.push(office);
                        }
                    }
                } catch (error) {
                    console.error(`Error processing row for Employee ID: ${row['Employee ID']}`, error);
                }
            }

            await Promise.all(officeList.map(async (office) => {
                if (!office.latitude || !office.longitude) {
                    console.warn(`Skipping office ${office.id} due to missing location data.`);
                    return;
                }

                await Promise.all(office.employees.map(async (employee) => {
                    const isGoodMatch = await isEmployeeOfficeGoodMatch(employee, office);

                    employee.nearByOffices = employee.nearByOffices || [];
                    office.nearByEmployees = office.nearByEmployees || [];
                    if (isGoodMatch) {
                        employee.nearByOffices.push(office);
                        office.nearByEmployees.push(employee);
                    }
                }));
            }));

            return { employeeList, officeList };
        }

        /**
         * Retrieves the geographical location for a given zip code.
         * @param {string} zipCode - The postal code.
         * @returns {Promise<{ latitude: number, longitude: number } | null>} The location or null if not found.
         */
        function getLocationFromZipCode(zipCode) {
            return new Promise((resolve, reject) => {
                if (!zipCode) {
                    resolve(null);
                    return;
                }

                if (LocalStorage.getItems('zipCodeLocationMap', zipCode)) {
                    resolve(LocalStorage.getItems('zipCodeLocationMap', zipCode));
                    return;
                }

                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: zipCode.toString() }, (results, status) => {
                    if (status === "OK" && results[0]) {
                        const location = results[0].geometry.location;
                        const latlanJSON = {
                            latitude: location.lat(),
                            longitude: location.lng(),
                        };
                        LocalStorage.setItems('zipCodeLocationMap', zipCode, latlanJSON);
                        resolve(latlanJSON);
                    } else {
                        console.warn(`Geocode failed for zip code ${zipCode}: ${status}`);
                        resolve(null);
                    }
                });
            });
        }

        function getTravelTime(originZipCode, destinationZipCode) {
            return new Promise((resolve, reject) => {
                const time = LocalStorage.getItems('zipCodeTimeMatrix', `${originZipCode},${destinationZipCode}`);
                if (time) {
                    resolve(time);
                    return;
                }

                const origin = LocalStorage.getItems('zipCodeLocationMap', originZipCode);
                const destination = LocalStorage.getItems('zipCodeLocationMap', destinationZipCode);
                const start = new google.maps.LatLng(origin.latitude, origin.longitude);
                const end = new google.maps.LatLng(destination.latitude, destination.longitude);
                const service = new google.maps.DistanceMatrixService();
                service.getDistanceMatrix({
                    origins: [start],
                    destinations: [end],
                    travelMode: "DRIVING",
                    unitSystem: google.maps.UnitSystem.METRIC,
                }, (response, status) => {
                    if (status === "OK") {
                        const element = response.rows[0].elements[0];
                        if (element.status === "OK") {
                            const time = element.duration.value;
                            LocalStorage.setItems('zipCodeTimeMatrix', `${originZipCode},${destinationZipCode}`, time);
                            resolve(time);
                        } else {
                            reject(new Error("Failed to get travel time."));
                        }
                    } else {
                        reject(new Error("Failed to get travel time."));
                    }
                });
            });
        }

        function getTravelDistance(originZipCode, destinationZipCode) {
            return new Promise((resolve, reject) => {
                const distance = LocalStorage.getItems('zipCodeDistanceMatrix', `${originZipCode},${destinationZipCode}`);
                if (distance) {
                    resolve(distance);
                    return;
                }

                const origin = LocalStorage.getItems('zipCodeLocationMap', originZipCode);
                const destination = LocalStorage.getItems('zipCodeLocationMap', destinationZipCode);
                const start = new google.maps.LatLng(origin.latitude, origin.longitude);
                const end = new google.maps.LatLng(destination.latitude, destination.longitude);
                const service = new google.maps.DistanceMatrixService();
                service.getDistanceMatrix({
                    origins: [start],
                    destinations: [end],
                    travelMode: "DRIVING",
                    unitSystem: google.maps.UnitSystem.METRIC,
                }, (response, status) => {
                    if (status === "OK") {
                        const element = response.rows[0].elements[0];
                        if (element.status === "OK") {
                            const distance = response.rows[0].elements[0].distance.value;
                            LocalStorage.setItems('zipCodeDistanceMatrix', `${originZipCode},${destinationZipCode}`, distance);
                            resolve(distance);
                        } else {
                            reject(new Error("Failed to get travel distance."));
                        }
                    } else {
                        reject(new Error("Failed to get travel distance."));
                    }
                });
            });
        }

        function getShortestDistance(originZipCode, destinationZipCode) {
            return new Promise((resolve, reject) => {
                let distance = LocalStorage.getItems('zipCodeDistanceMatrix', `${originZipCode},${destinationZipCode}`);
                if (distance) {
                    resolve(distance);
                    return;
                }

                const origin = LocalStorage.getItems('zipCodeLocationMap', originZipCode);
                const destination = LocalStorage.getItems('zipCodeLocationMap', destinationZipCode);
                const start = new google.maps.LatLng(origin.latitude, origin.longitude);
                const end = new google.maps.LatLng(destination.latitude, destination.longitude);
                distance = google.maps.geometry.spherical.computeDistanceBetween(start, end);

                LocalStorage.setItems('zipCodeDistanceMatrix', `${originZipCode},${destinationZipCode}`, distance);
                resolve(distance);
            });
        }

        /**
         * Plots office locations on the map and creates office buttons.
         * @param {{ officeList: Array<Object> }} data - The processed data.
         */
        async function plotOfficeLocations(officeList) {
            // Clear previous markers and buttons if any
            officeButtonsContainer.innerHTML = '';
            // Optionally, you can keep track of markers to clear them later

            await Promise.all(officeList.map(async (office) => {
                if (!office.latitude || !office.longitude) {
                    console.warn(`Skipping office ${office.id} due to missing location data.`);
                    return;
                }
                const officeLatLng = { lat: office.latitude, lng: office.longitude };

                // Create a button for the office
                const officeButton = document.createElement("button");
                officeButton.className = "office-btn";
                officeButton.textContent = office.id.replace(' Office Postcode', '');
                officeButton.addEventListener("click", () => focusOnOffice(officeLatLng));
                officeButtonsContainer.appendChild(officeButton);

                // Add an office marker
                new google.maps.Marker({
                    position: officeLatLng,
                    map: googleMap,
                    icon: {
                        url: "https://maps.google.com/mapfiles/kml/shapes/schools_maps.png", // Custom Office Icon
                        scaledSize: new google.maps.Size(30, 30),
                    },
                    title: `${office.id.replace(' Office Postcode', '')}: ${office.nearByEmployees.length} employees`,
                });

                let distances = await Promise.all(office.nearByEmployees.map((employee) => {
                    return getShortestDistance(employee.zip_code, office.zip_code);
                }));
                distances = distances.filter((d) => d > 0);
                const maxDistance = Math.max(...distances);

                if (maxDistance > 0) {
                    // Draw a circle around the office to represent the area (optional)
                    new google.maps.Circle({
                        strokeColor: "#0000FF",
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: "#0000FF",
                        fillOpacity: 0.1,
                        map: googleMap,
                        center: officeLatLng,
                        radius: maxDistance, // miles in meters
                    });
                }
            }));
        }

        /**
         * Plots employee locations on the map.
         * @param {{ employeeList: Array<Object> }} data - The processed data.
         */
        async function plotEmployeeLocations(employeeList) {
            employeeList.forEach(employee => {
                if (employee.nearByOffices && employee.nearByOffices.length > 0) {
                    return;
                }

                const employeeLatLng = { lat: employee.latitude, lng: employee.longitude };
                const employeeMarker = new google.maps.Marker({
                    position: employeeLatLng,
                    map: googleMap,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 5,
                        fillColor: 'red',
                        fillOpacity: 1,
                        strokeWeight: 1,
                        strokeColor: "white",
                    },
                    title: `Employee ID: ${employee.id}`,
                });
            });
        }

        async function isEmployeeOfficeGoodMatch(employee, office) {
            try {
                const distance = await getTravelDistance(employee.zip_code, office.zip_code);
                const time = await getTravelTime(employee.zip_code, office.zip_code);
                if (distance && distance < radiusMilesThreshold || time && time < travelTimeThreshold) {
                    return true;
                }
            } catch (error) {
                console.warn("Failed to evaluate isEmployeeOfficeGoodMatch:", error);
            }
            return false;
        }

        /**
         * Displays the route and travel time between two locations on the map.
         * @param {{ lat: number, lng: number }} origin - The starting point.
         * @param {{ lat: number, lng: number }} destination - The ending point.
         */
        async function showRouteAndTime(origin, destination) {
            const start = new google.maps.LatLng(origin.lat, origin.lng);
            const end = new google.maps.LatLng(destination.lat, destination.lng);

            try {
                const response = await directionsService.route({
                    origin: start,
                    destination: end,
                    travelMode: "DRIVING", // Changed to a valid travel mode
                });

                directionsRenderer.setDirections(response);

                const leg = response.routes[0].legs[0];
                travelInfo.textContent = `Travel time: ${leg.duration.text}, Distance: ${leg.distance.text}`;
            } catch (error) {
                console.error("Directions request failed:", error);
                alert("Failed to retrieve directions. Please try again.");
            }
        }

        /**
         * Focuses the map on a specific office location.
         * @param {{ lat: number, lng: number }} officeLatLng - The office location.
         */
        function focusOnOffice(officeLatLng) {
            googleMap.setCenter(officeLatLng);
            googleMap.setZoom(10); // Adjust zoom level as needed
        }

        // Event Listeners
        document.addEventListener("DOMContentLoaded", showUI);
        fileInput.addEventListener("change", handleFileUpload);
    </script>
</body>

</html>